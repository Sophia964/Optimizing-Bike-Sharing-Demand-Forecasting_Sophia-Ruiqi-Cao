---
title: "STA302 PROJECT PART3"
author: "GROUP9"
date: "2024-11-28"
output:
  pdf_document: default
  html_document: default
---
```{r}
# install.packages(c("tidyverse", "latex2exp", "gridExtra", "fastDummies", "car"))
library(tidyverse)
library(latex2exp)
library(gridExtra)
library(fastDummies)
library(car)
library(psych)
```

```{r}
# read and clean the original dataset
original_data <- read.csv("SeoulBikeData.csv", header = TRUE, fileEncoding = "UTF-8")
cleaned_data <- na.omit(original_data) # Remove rows with NA values

# remove the date variable (assuming it's the first column)
no_date_data <- cleaned_data[, -1]

# add time and rainfall-related variables
library(dplyr)
mutated_data <- no_date_data %>%
  mutate(
    LateNight = ifelse(Hour >= 0 & Hour <= 5, 1, 0),
    Morning = ifelse(Hour >= 6 & Hour <= 11, 1, 0),
    Afternoon = ifelse(Hour >= 12 & Hour <= 17, 1, 0),
    Evening = ifelse(Hour >= 18 & Hour <= 23, 1, 0),
  )

# create dummy variables for selected columns
library(fastDummies)
dummy_data <- dummy_cols(
  mutated_data,
  select_columns = c("Seasons", "Holiday", "Functioning_Day"),
  remove_selected_columns = TRUE
)

# randomly sample 50% of the dataset
set.seed(123) # for reproducibility
sampled_data <- dummy_data %>% sample_frac(0.5)

# display the final dataset
head(sampled_data)

```

```{r}
# split into training (50%) and test (50%) datasets
sample <- sample(1:nrow(sampled_data), size = 0.5 * nrow(sampled_data))
train_data <- sampled_data[sample, ]
test_data <- sampled_data[-sample, ]

describe(train_data)
describe(test_data)

```


```{r}
# Load required library
library(knitr)

# Create summary statistics function
create_summary_table <- function(data, title) {
  # Select specific columns
  selected_data <- data[, c("Rented_Bike_Count", "Hour", "Temperature", 
                            "Humidity", "Wind_speed")]

  # Compute summary statistics for selected numeric columns
  summary_stats <- data.frame(
    Min = sapply(selected_data, function(x) round(min(x, na.rm = TRUE), 3)),
    `1st Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.25, na.rm = TRUE), 3)),
    Median = sapply(selected_data, function(x) round(median(x, na.rm = TRUE), 3)),
    Mean = sapply(selected_data, function(x) round(mean(x, na.rm = TRUE), 3)),
    `3rd Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.75, na.rm = TRUE), 3)),
    Max = sapply(selected_data, function(x) round(max(x, na.rm = TRUE), 3))
  )

  # Transpose the data for display
  summary_table <- t(summary_stats)
  colnames(summary_table) <- colnames(selected_data)
  rownames(summary_table) <- c("Min", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max")

  # Display the table
  kable(summary_table, caption = title, align = 'c', booktabs = TRUE)
}

# Generate and print tables for train and test datasets
create_summary_table(train_data, "Numerical Summary of Training Data Variables")

```

```{r}
# Load required library
library(knitr)

# Create summary statistics function
create_summary_table <- function(data, title) {
  # Select specific columns
  selected_data <- data[, c(
                            "Dew_point_temperatur", "Solar_Radiation", 
                            "Rainfall", "Snowfall")]

  # Compute summary statistics for selected numeric columns
  summary_stats <- data.frame(
    Min = sapply(selected_data, function(x) round(min(x, na.rm = TRUE), 3)),
    `1st Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.25, na.rm = TRUE), 3)),
    Median = sapply(selected_data, function(x) round(median(x, na.rm = TRUE), 3)),
    Mean = sapply(selected_data, function(x) round(mean(x, na.rm = TRUE), 3)),
    `3rd Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.75, na.rm = TRUE), 3)),
    Max = sapply(selected_data, function(x) round(max(x, na.rm = TRUE), 3))
  )

  # Transpose the data for display
  summary_table <- t(summary_stats)
  colnames(summary_table) <- colnames(selected_data)
  rownames(summary_table) <- c("Min", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max")

  # Display the table
  kable(summary_table, caption = title, align = 'c', booktabs = TRUE)
}

# Generate and print tables for train and test datasets
create_summary_table(train_data, "Continued: Numerical Summary of Training Data Variables")
```

```{r}
# Load required library
library(knitr)

# Create summary statistics function
create_summary_table <- function(data, title) {
  # Select specific columns
  selected_data <- data[, c("Rented_Bike_Count", "Hour", "Temperature", 
                            "Humidity", "Wind_speed")]

  # Compute summary statistics for selected numeric columns
  summary_stats <- data.frame(
    Min = sapply(selected_data, function(x) round(min(x, na.rm = TRUE), 3)),
    `1st Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.25, na.rm = TRUE), 3)),
    Median = sapply(selected_data, function(x) round(median(x, na.rm = TRUE), 3)),
    Mean = sapply(selected_data, function(x) round(mean(x, na.rm = TRUE), 3)),
    `3rd Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.75, na.rm = TRUE), 3)),
    Max = sapply(selected_data, function(x) round(max(x, na.rm = TRUE), 3))
  )

  # Transpose the data for display
  summary_table <- t(summary_stats)
  colnames(summary_table) <- colnames(selected_data)
  rownames(summary_table) <- c("Min", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max")

  # Display the table
  kable(summary_table, caption = title, align = 'c', booktabs = TRUE)
}

# Generate and print tables for train and test datasets
create_summary_table(test_data, "Numerical Summary of Testing Data Variables")

```

```{r}
# Load required library
library(knitr)

# Create summary statistics function
create_summary_table <- function(data, title) {
  # Select specific columns
  selected_data <- data[, c(
                            "Dew_point_temperatur", "Solar_Radiation", 
                            "Rainfall", "Snowfall")]

  # Compute summary statistics for selected numeric columns
  summary_stats <- data.frame(
    Min = sapply(selected_data, function(x) round(min(x, na.rm = TRUE), 3)),
    `1st Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.25, na.rm = TRUE), 3)),
    Median = sapply(selected_data, function(x) round(median(x, na.rm = TRUE), 3)),
    Mean = sapply(selected_data, function(x) round(mean(x, na.rm = TRUE), 3)),
    `3rd Qu.` = sapply(selected_data, function(x) round(quantile(x, 0.75, na.rm = TRUE), 3)),
    Max = sapply(selected_data, function(x) round(max(x, na.rm = TRUE), 3))
  )

  # Transpose the data for display
  summary_table <- t(summary_stats)
  colnames(summary_table) <- colnames(selected_data)
  rownames(summary_table) <- c("Min", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max")

  # Display the table
  kable(summary_table, caption = title, align = 'c', booktabs = TRUE)
}

# Generate and print tables for train and test datasets
create_summary_table(test_data, "Continued: Numerical Summary of Testing Data Variables")

```

```{r}
# load required libraries
library(ggplot2)
library(gridExtra) # For grid layout

# function to draw histogram
plot_histogram <- function(data, variable, binwidth, fill_color, title) {
  ggplot(data, aes_string(x = variable)) +
    geom_histogram(binwidth = binwidth, fill = fill_color, color = "grey", alpha = 0.7) +
    labs(title = title, x = variable, y = "Frequency") +
    theme_minimal()
}

# create histograms for each variable
p1 <- plot_histogram(train_data, "Rented_Bike_Count", binwidth = 100, fill_color = "grey", title = "Histogram of Rented_Bike_Count")
p2 <- plot_histogram(train_data, "Temperature", binwidth = 5, fill_color = "grey", title = "Histogram of Temperature")
p3 <- plot_histogram(train_data, "Dew_point_temperatur", binwidth = 0.5, fill_color = "grey", title = "Histogram of Dew_point_temperature")
p4 <- plot_histogram(train_data, "Humidity", binwidth = 0.5, fill_color = "grey", title = "Histogram of Humidity")
p5 <- plot_histogram(train_data, "Wind_speed", binwidth = 0.5, fill_color = "grey", title = "Histogram of Wind_speed")
p6 <- plot_histogram(train_data, "Visibility", binwidth = 0.5, fill_color = "grey", title = "Histogram of Visibility")
p7 <- plot_histogram(train_data, "Solar_Radiation", binwidth = 0.5, fill_color = "grey", title = "Histogram of Solar_Radiation")
p8 <- plot_histogram(train_data, "Rainfall", binwidth = 0.5, fill_color = "grey", title = "Histogram of Rainfall")
p9 <- plot_histogram(train_data, "Snowfall", binwidth = 0.5, fill_color = "grey", title = "Histogram of Snowfall")

# arrange all plots in a grid layout
grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, ncol = 3) 
```

```{r}
# fitted model 1
model1 <- lm(Rented_Bike_Count ~ Temperature + Dew_point_temperatur + Humidity + Wind_speed + Visibility + Solar_Radiation + Rainfall + LateNight + Morning + Afternoon + Holiday_Holiday, data = train_data)
```

```{r}
# calculate e_hat and y_hat for model 1
y_hat <- fitted(model1)
e_hat <- resid(model1)
standardized_residuals <- rstandard(model1)

par(mfrow = c(4, 3), mar = c(4, 4, 2, 1))

# residual plot for model 1
plot(e_hat ~ y_hat, main = "Model 1 Residual vs Fitted", xlab = "Fitted", ylab = "Residuals")
plot(e_hat ~ train_data$Temperature, main = "Model 1 Residual vs Temperature", xlab = "Temperature", ylab = "Residuals")
plot(e_hat ~ train_data$Humidity, main = "Model 1 Residual vs Humidity", xlab = "Humidity", ylab = "Residuals")
plot(e_hat ~ train_data$Wind_speed, main = "Model 1 Residual vs Wind_speed", xlab = "Wind_speed", ylab = "Residuals")
plot(e_hat ~ train_data$Visibility, main = "Model 1 Residual vs Visibility", xlab = "Visibility", ylab = "Residuals")
plot(e_hat ~ train_data$Dew_point_temperatur, main = "Model 1 Residual vs Dew_point_temperatur", xlab = "Dew_point_temperatur", ylab = "Residuals")
plot(e_hat ~ train_data$Solar_Radiation, main = "Model 1 Residual vs Solar_Radiation", xlab = "Solar_Radiation", ylab = "Residuals")
plot(e_hat ~ train_data$Rainfall, main = "Model 1 Residual vs Rainfall", xlab = "Rainfall", ylab = "Residuals")

train_data$TimeOfDay <- factor(
  apply(train_data[, c("LateNight", "Morning", "Afternoon", "Evening")], 1, function(x) {
    if (x["LateNight"] == 1) return("LateNight")
    if (x["Morning"] == 1) return("Morning")
    if (x["Afternoon"] == 1) return("Afternoon")
    if (x["Evening"] == 1) return("Evening")
  }),
  levels = c("LateNight", "Morning", "Afternoon", "Evening")
)
boxplot(e_hat ~ train_data$TimeOfDay, 
        main = "Model 1 Residuals by Time of Day", 
        xlab = "Time of Day", 
        ylab = "Residuals", 
        names = c("LateNight", "Morning", "Afternoon", "Evening"), las = 2)

boxplot(e_hat ~ train_data$Holiday_Holiday, main = "Model 1 Residual by Holiday", xlab = "Holiday", ylab = "Residual", names = c("Holiday", "No_Holiday"))

# QQ plot for model 1
qqnorm(standardized_residuals, main = "Model 1 Normal QQ-Plot")
qqline(standardized_residuals)

# summary model 1
summary(model1)
```
```{r}
library(psych)
columns <- train_data %>%
  select(Rented_Bike_Count, Temperature, Dew_point_temperatur, Humidity, Wind_speed, Visibility, Solar_Radiation, Rainfall)

# scatter plot matrix between each predictor
plot(columns, col="black", main="Pairwise Scatterplot")
```
```{r}
# load required packages
library(car)    # For calculating VIF
library(knitr)  # For generating kable tables

# calculate VIF
vif_values <- vif(model1)

# convert VIF output to a data frame for easier table generation
vif_table <- data.frame(
  Variable = names(vif_values),
  VIF = round(as.numeric(vif_values), 3)
)

# generate a kable table
kable(vif_table, col.names = c("Variable", "VIF"), caption = "VIF Summary Table")
```

```{r}
# fitted model 2
model2 <- lm(Rented_Bike_Count ~ Temperature + Humidity + Wind_speed + Visibility + Solar_Radiation + Rainfall + LateNight + Morning + Afternoon + Holiday_Holiday, data = train_data)
```

```{r}
# calculate e_hat and y_hat for model 2
y_hat <- fitted(model2)
e_hat <- resid(model2)
standardized_residuals <- rstandard(model2)

par(mfrow = c(4, 3), mar = c(4, 4, 2, 1))

# residual plot for model 2
plot(e_hat ~ y_hat, main = "Model 2 Residual vs Fitted", xlab = "Fitted", ylab = "Residuals")
plot(e_hat ~ train_data$Temperature, main = "Model 2 Residual vs Temperature", xlab = "Temperature", ylab = "Residuals")
plot(e_hat ~ train_data$Humidity, main = "Model 2 Residual vs Humidity", xlab = "Humidity", ylab = "Residuals")
plot(e_hat ~ train_data$Wind_speed, main = "Model 2 Residual vs Wind_speed", xlab = "Wind_speed", ylab = "Residuals")
plot(e_hat ~ train_data$Visibility, main = "Model 2 Residual vs Visibility", xlab = "Visibility", ylab = "Residuals")
plot(e_hat ~ train_data$Solar_Radiation, main = "Model 2 Residual vs Solar_Radiation", xlab = "Solar_Radiation", ylab = "Residuals")
plot(e_hat ~ train_data$Rainfall, main = "Model 2 Residual vs Rainfall", xlab = "Rainfall", ylab = "Residuals")

train_data$TimeOfDay <- factor(
  apply(train_data[, c("LateNight", "Morning", "Afternoon", "Evening")], 1, function(x) {
    if (x["LateNight"] == 1) return("LateNight")
    if (x["Morning"] == 1) return("Morning")
    if (x["Afternoon"] == 1) return("Afternoon")
    if (x["Evening"] == 1) return("Evening")
  }),
  levels = c("LateNight", "Morning", "Afternoon", "Evening")
)
boxplot(e_hat ~ train_data$TimeOfDay, 
        main = "Model 2 Residuals by Time of Day", 
        xlab = "Time of Day", 
        ylab = "Residuals", 
        names = c("LateNight", "Morning", "Afternoon", "Evening"), las = 2)

boxplot(e_hat ~ train_data$Holiday_Holiday, main = "Model 2 Residual by Holiday", xlab = "Holiday", ylab = "Residual", names = c("Holiday", "No_Holiday"))

# QQ plot for model 2
qqnorm(standardized_residuals, main = "Model 2 Normal QQ-Plot")
qqline(standardized_residuals)

# summary model 2
summary(model2)
```
```{r}
# load required packages
library(car)    # For calculating VIF
library(knitr)  # For generating kable tables

# calculate VIF
vif_values <- vif(model2)

# convert VIF output to a data frame for easier table generation
vif_table <- data.frame(
  Variable = names(vif_values),
  VIF = round(as.numeric(vif_values), 3)
)

# generate a kable table
kable(vif_table, col.names = c("Variable", "VIF"), caption = "VIF Summary Table")
```

```{r}
# load necessary library
library(MASS)

# add a constant to ensure the response variable is strictly positive
train_data$Rented_Bike_Count_Positive <- train_data$Rented_Bike_Count + 1
train_data$Rainfall_Positive <- train_data$Rainfall + 1

# apply Box-Cox transformation for Rented_Bike_Count
model_rented <- lm(Rented_Bike_Count_Positive ~ 1, data = train_data)
bc_rented <- boxcox(model_rented, lambda = seq(-2, 2, 0.1))
lambda_rented_opt <- bc_rented$x[which.max(bc_rented$y)]

# apply transformation based on lambda_rented_opt
train_data_transformed <- train_data
if (lambda_rented_opt == 0) {
  train_data_transformed$Rented_Bike_Count_transformed <- log(train_data$Rented_Bike_Count_Positive)
} else {
  train_data_transformed$Rented_Bike_Count_transformed <- (train_data$Rented_Bike_Count_Positive^lambda_rented_opt - 1) / lambda_rented_opt
}

# apply Box-Cox transformation for Rainfall
model_rainfall <- lm(Rainfall_Positive ~ 1, data = train_data)
bc_rainfall <- boxcox(model_rainfall, lambda = seq(-2, 2, 0.1))
lambda_rainfall_opt <- bc_rainfall$x[which.max(bc_rainfall$y)]

# apply transformation based on lambda_rainfall_opt
if (lambda_rainfall_opt == 0) {
  train_data_transformed$Rainfall_transformed <- log(train_data$Rainfall_Positive)
} else {
  train_data_transformed$Rainfall_transformed <- (train_data$Rainfall_Positive^lambda_rainfall_opt - 1) / lambda_rainfall_opt
}

# ensure no NA/NaN/Inf values in transformed variables
train_data_transformed <- train_data_transformed[complete.cases(train_data_transformed$Rented_Bike_Count_transformed, train_data_transformed$Rainfall_transformed), ]

# fit the transformed regression model 3
model3 <- lm(Rented_Bike_Count_transformed ~ Temperature + Humidity + Wind_speed + Visibility + Solar_Radiation + Rainfall_transformed + LateNight + Morning + Afternoon + Holiday_Holiday, data = train_data_transformed)
```

```{r}
# calculate e_hat and y_hat for model 3
y_hat <- fitted(model3)
e_hat <- resid(model3)
standardized_residuals <- rstandard(model3)

par(mfrow = c(4, 3), mar = c(4, 4, 2, 1))

# residual plot for model 3
plot(e_hat ~ y_hat, main = "Model 3 Residual vs Fitted", xlab = "Fitted", ylab = "Residuals")
plot(e_hat ~ train_data$Temperature, main = "Model 3 Residual vs Temperature", 
     xlab = "Temperature", ylab = "Residuals")
plot(e_hat ~ train_data$Humidity, main = "Model 3 Residual vs Humidity", 
     xlab = "Humidity ", ylab = "Residuals")
plot(e_hat ~ train_data$Wind_speed, main = "Model 3 Residual vs Wind_Speed", 
     xlab = "Wind_Speed", ylab = "Residuals")
plot(e_hat ~ train_data$Visibility, main = "Model 3 Residual vs Visibility", 
     xlab = "Visibility", ylab = "Residuals")
plot(e_hat ~ train_data$Solar_Radiation, main = "Model 3 Residual vs Solar_Radiation", 
     xlab = "Solar_Radiation", ylab = "Residuals")
plot(e_hat ~ train_data_transformed$Rainfall_transformed, main = "Model 3 Residual vs Rainfall_transformed", xlab = "Rainfall_transformed", ylab = "Residuals")

train_data$TimeOfDay <- factor(
  apply(train_data[, c("LateNight", "Morning", "Afternoon", "Evening")], 1, function(x) {
    if (x["LateNight"] == 1) return("LateNight")
    if (x["Morning"] == 1) return("Morning")
    if (x["Afternoon"] == 1) return("Afternoon")
    if (x["Evening"] == 1) return("Evening")
  }),
  levels = c("LateNight", "Morning", "Afternoon", "Evening")
)
boxplot(e_hat ~ train_data$TimeOfDay, 
        main = "Model 3 Residuals by Time of Day", 
        xlab = "Time of Day", 
        ylab = "Residuals", 
        names = c("LateNight", "Morning", "Afternoon", "Evening"), las = 2)

boxplot(e_hat ~ train_data$Holiday_Holiday, main = "Model 3 Residual by Holiday", xlab = "Holiday", ylab = "Residual", names = c("Holiday", "No_Holiday"))

# QQ plot for model 3
qqnorm(standardized_residuals, main = "Model 3 Normal QQ-Plot")
qqline(standardized_residuals)

summary(model3)
```
```{r}
# fitted model 4 (subset of model 3)
model4 <- lm(Rented_Bike_Count_transformed ~ Temperature + Humidity + Rainfall_transformed + LateNight + Morning + Afternoon + Holiday_Holiday, data = train_data_transformed)
```

```{r}
# calculate e_hat and y_hat for model 4
y_hat <- fitted(model4)
e_hat <- resid(model4)
standardized_residuals <- rstandard(model4)

par(mfrow = c(4, 3), mar = c(4, 4, 2, 1))

# residual plot for model 4
plot(e_hat ~ y_hat, main = "Model 4 Residual vs Fitted", xlab = "Fitted", ylab = "Residuals")
plot(e_hat ~ train_data$Temperature, main = "Model 4 Residual vs Temperature", 
     xlab = "Temperature", ylab = "Residuals")
plot(e_hat ~ train_data$Humidity, main = "Model 4 Residual vs Humidity", 
     xlab = "Humidity ", ylab = "Residuals")
plot(e_hat ~ train_data_transformed$Rainfall_transformed, main = "Model 4 Residual vs Rainfall_transformed", xlab = "Rainfall_transformed ", ylab = "Residuals")

train_data$TimeOfDay <- factor(
  apply(train_data[, c("LateNight", "Morning", "Afternoon", "Evening")], 1, function(x) {
    if (x["LateNight"] == 1) return("LateNight")
    if (x["Morning"] == 1) return("Morning")
    if (x["Afternoon"] == 1) return("Afternoon")
    if (x["Evening"] == 1) return("Evening")
  }),
  levels = c("LateNight", "Morning", "Afternoon", "Evening")
)
boxplot(e_hat ~ train_data$TimeOfDay, 
        main = "Model 4 Residuals by Time of Day", 
        xlab = "Time of Day", 
        ylab = "Residuals", 
        names = c("LateNight", "Morning", "Afternoon", "Evening"),las = 2)

boxplot(e_hat ~ train_data$Holiday_Holiday, main = "Model 4 Residual by Holiday", xlab = "Holiday", ylab = "Residual", names = c("Holiday", "No_Holiday"))

# QQ plot for model 4
qqnorm(standardized_residuals, main = "Model 4 Normal QQ-Plot")
qqline(standardized_residuals)

summary(model4)
```

```{r}
# conduct a partial-F test
anova(model4, model3)
```

```{r}
stepAIC(model4, direction = "backward", scope = list(lower = lm(Rented_Bike_Count_transformed ~ 1, data = train_data_transformed), upper = model4), k = 2)
```

```{r}
stepAIC(model4, direction = "forward", scope = list(lower = lm(Rented_Bike_Count_transformed ~ 1, data = train_data_transformed), upper = model4), k = 2)
```

```{r}
stepAIC(model4, direction = "both", scope = list(lower = lm(Rented_Bike_Count_transformed ~ 1, data = train_data_transformed), upper = model4), k = 2)
```

```{r}
# fitted model 5 (same as model 4)
model5 <- lm(Rented_Bike_Count_transformed ~ Temperature + Humidity + Rainfall_transformed + LateNight + Morning + Afternoon + Holiday_Holiday, data = train_data_transformed)
summary(model5)
```

```{r}
# calculate e_hat and y_hat for model 5
y_hat <- fitted(model5)
e_hat <- resid(model5)
standardized_residuals <- rstandard(model5)

par(mfrow = c(4, 3), mar = c(4, 4, 2, 1))

# residual plot for model 5
plot(e_hat ~ y_hat, main = "Model 5 Residual vs Fitted", xlab = "Fitted", ylab = "Residuals")
plot(e_hat ~ train_data$Temperature, main = "Model 5 Residual vs Temperature", 
     xlab = "Temperature", ylab = "Residuals")
plot(e_hat ~ train_data$Humidity, main = "Model 5 Residual vs Humidity", 
     xlab = "Humidity ", ylab = "Residuals")
plot(e_hat ~ train_data_transformed$Rainfall_transformed, main = "Model 5 Residual vs Rainfall_transformed", xlab = "Rainfall_transformed ", ylab = "Residuals")

train_data$TimeOfDay <- factor(
  apply(train_data[, c("LateNight", "Morning", "Afternoon", "Evening")], 1, function(x) {
    if (x["LateNight"] == 1) return("LateNight")
    if (x["Morning"] == 1) return("Morning")
    if (x["Afternoon"] == 1) return("Afternoon")
    if (x["Evening"] == 1) return("Evening")
  }),
  levels = c("LateNight", "Morning", "Afternoon", "Evening")
)
boxplot(e_hat ~ train_data$TimeOfDay, 
        main = "Model 5 Residuals by Time of Day", 
        xlab = "Time of Day", 
        ylab = "Residuals", 
        names = c("LateNight", "Morning", "Afternoon", "Evening"), las = 2)

boxplot(e_hat ~ train_data$Holiday_Holiday, main = "Model 5 Residual by Holiday", xlab = "Holiday", ylab = "Residual", names = c("Holiday", "No_Holiday"))

# QQ plot for model 5
qqnorm(standardized_residuals, main = "Model 5 Normal QQ-Plot")
qqline(standardized_residuals)

summary(model5)
```

```{r}
# load required library
library(knitr)

# create a function to compute model metrics
model_metrics <- function(model, model_name) {
  # extract the number of predictors
  n_predictors <- length(coef(model)) - 1  # Subtract 1 for the intercept
  
  # Adjusted R-squared
  adj_r_squared <- summary(model)$adj.r.squared
  
  # AIC
  aic <- AIC(model)
  
  # BIC
  bic <- BIC(model)
  
  # return metrics as a data frame row
  data.frame(
    Model = model_name,
    `N of Predictors` = n_predictors,
    `Adjust R Square` = round(adj_r_squared, 4),
    AIC = round(aic, 4),
    BIC = round(bic, 4)
  )
}

# apply the function to each model (including Model 1)
model_comparison <- rbind(
  model_metrics(model1, "Model_1"),
  model_metrics(model2, "Model_2"),
  model_metrics(model3, "Model_3"),
  model_metrics(model4, "Model_4"),
  model_metrics(model5, "Model_5")
)

# print the comparison table
kable(model_comparison, caption = "Model Comparison", align = 'c')
```

```{r}
# load necessary library
library(MASS)

# add a constant to ensure the response variable is strictly positive(test set)
test_data$Rented_Bike_Count_Positive <- test_data$Rented_Bike_Count + 1
test_data$Rainfall_Positive <- test_data$Rainfall + 1

# apply Box-Cox transformation for Rented_Bike_Count(test set)
model_rented <- lm(Rented_Bike_Count_Positive ~ 1, data = test_data)
bc_rented <- boxcox(model_rented, lambda = seq(-2, 2, 0.1))
lambda_rented_opt <- bc_rented$x[which.max(bc_rented$y)]

# apply transformation based on lambda_rented_opt(test set)
test_data_transformed <- test_data
if (lambda_rented_opt == 0) {
  test_data_transformed$Rented_Bike_Count_transformed <- log(test_data$Rented_Bike_Count_Positive)
} else {
  test_data_transformed$Rented_Bike_Count_transformed <- (test_data$Rented_Bike_Count_Positive^lambda_rented_opt - 1) / lambda_rented_opt
}

# apply Box-Cox transformation for Rainfall(test set)
model_rainfall <- lm(Rainfall_Positive ~ 1, data = test_data)
bc_rainfall <- boxcox(model_rainfall, lambda = seq(-2, 2, 0.1))
lambda_rainfall_opt <- bc_rainfall$x[which.max(bc_rainfall$y)]

# apply transformation based on lambda_rainfall_opt(test set)
if (lambda_rainfall_opt == 0) {
  test_data_transformed$Rainfall_transformed <- log(test_data$Rainfall_Positive)
} else {
  test_data_transformed$Rainfall_transformed <- (test_data$Rainfall_Positive^lambda_rainfall_opt - 1) / lambda_rainfall_opt
}

# ensure no NA/NaN/Inf values in transformed variables(test set)
test_data_transformed <- test_data_transformed[complete.cases(test_data_transformed$Rented_Bike_Count_transformed, test_data_transformed$Rainfall_transformed), ]

```

```{r}
# fitted the final model(test set)
final_test <- lm(Rented_Bike_Count_transformed ~ Temperature + Humidity + Rainfall_transformed + LateNight + Morning + Afternoon + Holiday_Holiday, data = test_data_transformed)
``` 

```{r}
# calculate e_hat and y_hat for final_test
y_hat <- fitted(final_test)
e_hat <- resid(final_test)
standardized_residuals <- rstandard(final_test)

par(mfrow = c(4, 3), mar = c(4, 4, 2, 1))

# residual plot for final_test
plot(e_hat ~ y_hat, main = "Final_Test Residual vs Fitted", xlab = "Fitted", ylab = "Residuals")
plot(e_hat ~ test_data$Temperature, main = "Final_Test Residual vs Temperature", 
     xlab = "Temperature", ylab = "Residuals")
plot(e_hat ~ test_data$Humidity, main = "Final_Test Residual vs Humidity", 
     xlab = "Humidity ", ylab = "Residuals")
plot(e_hat ~ test_data_transformed$Rainfall_transformed, main = "Final_Test Residual vs Rainfall_transformed", xlab = "Rainfall_transformed ", ylab = "Residuals")

test_data$TimeOfDay <- factor(
  apply(train_data[, c("LateNight", "Morning", "Afternoon", "Evening")], 1, function(x) {
    if (x["LateNight"] == 1) return("LateNight")
    if (x["Morning"] == 1) return("Morning")
    if (x["Afternoon"] == 1) return("Afternoon")
    if (x["Evening"] == 1) return("Evening")
  }),
  levels = c("LateNight", "Morning", "Afternoon", "Evening")
)
boxplot(e_hat ~ test_data$TimeOfDay, 
        main = "Final_Test Residuals by Time of Day", 
        xlab = "Time of Day", 
        ylab = "Residuals", 
        names = c("LateNight", "Morning", "Afternoon", "Evening"), las = 2)

boxplot(e_hat ~ test_data$Holiday_Holiday, main ="Final_Test Residual by Holiday", xlab = "Holiday", ylab = "Residual", names = c("Holiday", "No_Holiday"))

# QQ plot for final_test
qqnorm(standardized_residuals, main = "Final_Test Normal QQ-Plot")
qqline(standardized_residuals)

summary(final_test)
```

```{r}
# Function to diagnose and count problematic observations
count_problematic_observations <- function(model, data) {
  n <- nrow(data)
  p <- length(coef(model)) - 1
  
  # Cutoff values
  h_cut <- 2 * (p + 1) / n
  D_cut <- qf(0.5, p + 1, n - p - 1)
  fits_cut <- 2 * sqrt((p + 1) / n)
  beta_cut <- 2 / sqrt(n)
  
  # Calculating problematic observations
  leverage_points <- which(hatvalues(model) > h_cut)
  small_outliers <- which(rstandard(model) > 2 | rstandard(model) < -2)
  large_outliers <- which(rstandard(model) > 4 | rstandard(model) < -4)
  cooks_points <- which(cooks.distance(model) > D_cut)
  diffits_points <- which(abs(dffits(model)) > fits_cut)
  
  # Counting influential points for each coefficient (DFBETAS)
  dfbetas_points <- sapply(1:(p + 1), function(i) {
    length(which(abs(dfbetas(model)[, i]) > beta_cut))
  })
  
  # Summarizing counts
  result <- list(
    leverage_points_count = length(leverage_points),
    small_outliers_count = length(small_outliers),
    large_outliers_count = length(large_outliers),
    cooks_points_count = length(cooks_points),
    diffits_points_count = length(diffits_points),
    dfbetas_points_count = sum(dfbetas_points) # Total influential points across coefficients
  )
  
  return(result)
}

# Applying the function to train and test data
train_results <- count_problematic_observations(model5, train_data_transformed)
test_results <- count_problematic_observations(final_test, test_data_transformed)

# Print results
cat("Train Data Results:\n")
print(train_results)
cat("\nTest Data Results:\n")
print(test_results)
```


```{r}
# load required library
library(knitr)

# define Train and Test Data Results
train_results <- list(
  leverage_points_count = 181,
  small_outliers_count = 101,
  large_outliers_count = 24,
  cooks_points_count = 0,
  diffits_points_count = 123,
  dfbetas_points_count = 711
)

test_results <- list(
  leverage_points_count = 207,
  small_outliers_count = 104,
  large_outliers_count = 17,
  cooks_points_count = 0,
  diffits_points_count = 122,
  dfbetas_points_count = 749
)

# calculate totals
total_train <- sum(unlist(train_results))
total_test <- sum(unlist(test_results))

# create the table
results <- data.frame(
  Metric = c("Leverage", "Small_Outliers", "Large_Outliers", "Cooks", "DFFITS", "Total_DFBETAS", "Total_Problematic_Observations"),
  Model5_train = c(
    train_results$leverage_points_count,
    train_results$small_outliers_count,
    train_results$large_outliers_count,
    train_results$cooks_points_count,
    train_results$diffits_points_count,
    train_results$dfbetas_points_count,
    total_train
  ),
  Model5_test = c(
    test_results$leverage_points_count,
    test_results$small_outliers_count,
    test_results$large_outliers_count,
    test_results$cooks_points_count,
    test_results$diffits_points_count,
    test_results$dfbetas_points_count,
    total_test
  )
)

# add ratio columns
results$Model5_train_ratio <- results$Model5_train / 2190
results$Model5_test_ratio <- results$Model5_test / 2190

# print the table to console
print(results)

# display the table with kable for formatting
kable(results, caption = "Comparison of Model5 Metrics in Training and Testing Data")
```

```{r}
# load required library
library(car)
library(knitr)

# calculate VIF for Model 5 (Training Data)
vif_train <- vif(model5)

# format VIF for Training Data
vif_train_df <- data.frame(
  Variable = names(vif_train),
  Model5_Training = round(vif_train, 4)
)

# fit Model 5 to Testing Data
model4_test <- lm(Rented_Bike_Count ~ Temperature + Humidity + Rainfall + LateNight + Morning + Afternoon + Holiday_Holiday, 
                  data = test_data)

# calculate VIF for Testing Data
vif_test <- vif(model4_test)

# format VIF for Testing Data
vif_test_df <- data.frame(
  Variable = names(vif_test),
  Model5_Testing = round(vif_test, 4)
)

# merge Training and Testing VIF into a single table
vif_comparison <- merge(vif_train_df, vif_test_df, by = "Variable")

# print the VIF Comparison Table
kable(vif_comparison, caption = "Variance Inflation Factor (VIF) Values", align = "c")
```

```{r}
library(knitr)

# load the data frame
table <- data.frame(
  Term = c("Intercept", "Temperature", "Humidity", "Rainfall_transformed", "LateNight", "Morning", "Afternoon", "Holiday_Holiday"),
  Estimate_Train = c(24.76509, 0.43070, -0.06976, -28.94982, -8.56234, -3.37717, -3.65439, -3.58649),
  Std_Error_Train = c(0.57993, 0.01291, 0.00896, 1.84066, 0.42725, 0.42101, 0.43192, 0.69805),
  Pr_Train = c("< 2e-16", "< 2e-16", "1.06e-14", "< 2e-16", "< 2e-16", "1.69e-15", "< 2e-16", "3.03e-07"),
  Estimate_Test = c(26.392344, 0.440388, -0.095323, -25.901090, -8.396633, -4.152670, -4.412398, -3.964966),
  Std_Error_Test = c(0.564275, 0.012534, 0.008653, 1.708935, 0.413824, 0.408383, 0.425073, 0.622652),
  Pr_Test = c("< 2e-16", "< 2e-16", "< 2e-16", "< 2e-16", "< 2e-16", "< 2e-16", "< 2e-16", "2.33e-10")
)

# print the table
print(table)

# format as a table
kable(table, caption = "Comparison of Model Coefficients, Standard Error, and P-value in Training and Testing data")
```